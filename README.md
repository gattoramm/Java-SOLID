# Java-SOLID

__*SOLID*__ - аббревиатура пяти основных принципов проектирования в объектно-ориентированном программировании —
* __*S*__*ingle responsibility* - Принцип единственной ответственности
* __*O*__*pen-closed* - Принцип открытости / закрытости
* __*L*__*iskov substitution* - Принцип подстановки Барбары Лисков
* __*I*__*nterface segregation* - Принцип разделения интерфейса
* __*D*__*ependency inversion* - Принцип инверсии зависимостей

## __S__ - __SRP__

__Single Responsibility Principle__ - Принцип единственной ответственности

> Каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.

__Приложение, которое нарушает принцип SCP__:
[Пример](src/ITVDN/Part1_Single_Responsibility_Principle/part11_moder_srp_violation)

__Приложение, которое соблюдает принцип SCP__:
[Пример](src/ITVDN/Part1_Single_Responsibility_Principle/part12_moder_srp_solution)

__Приложение, которое соблюдает принцип SCP на примере шаблона DAO__:
[Пример](src/ITVDN/Part1_Single_Responsibility_Principle/part13_employee_architecture)

## __O__ - __OSP__

__Open-Closed Principle__ - Принцип открытости-закрытости

> Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для изменения.

__Приложение, которое нарушает принцип OSP__:
[Пример1](src/ITVDN/Part2_Open_Closed_Principle/part21_loan_ocp_handler),
[Пример2](src/ITVDN/Part2_Open_Closed_Principle/part23_shape_ocp_violation)

__Приложение, которое поддерживает принцип OSP__:
[Пример1](src/ITVDN/Part2_Open_Closed_Principle/part22_loan_ocp_solution),
[Пример2](src/ITVDN/Part2_Open_Closed_Principle/part24_shape_ocp_solution)

## __L__ - __LSP__

__Liskov Substitution Principle__ - Принцип подстановки Барбары Лисков

> Должна быть возможность вместо базового типа подставить любой его подтип

Представляет собой руководство по созданию иерархии наследований.

Если для каждого объекта o1 типа S существует объект o2 типа T, такой, что для любой программы P, определенной в терминах T, поведение P не изменяется при замене o1 на o2, то S является подтипом T.

Помогает четко сформулировать иерархию классов и определить функционал для базовых и производных классов и избежать возможных проблем при применении полиморфизма.

__Приложение, которое нарушает принцип LSP__:
[Пример](src/ITVDN/Part3_Liskov_Substitution_Principle/part31_mediaplayer_lsp_violation)

__Приложение, которое поддерживает принцип LSP__:
[Пример](src/ITVDN/Part3_Liskov_Substitution_Principle/part32_mediaplayer_lsp_solution)

## __I__ - __ISP__

__Interface Segregation Principle__ - Принцип разделения интерфейса

> Программные сущности не должны зависеть от методов, которые они не используют.
 
Принцип разделения интерфейсов относится к тем случаям, когда классы имеют "жирный интерфейс", то есть слишком раздутый интерфейс, не все методы и свойства которого используются и могут быть восстребованы. Таким образом, интерфейс получается слишком избыточен или "жирным". 
Клиенты не должны вынужденно зависеть от методов, которыми не пользуются.

__Приложение, которое нарушает принцип ISP__:
[Пример1](src/ITVDN/Part4_Interface_Segregation_Principle/part41_isp_violation),
[Пример2](src/ITVDN/Part4_Interface_Segregation_Principle/part43_order_isp_violation)

__Приложение, которое поддерживает принцип ISP__:
[Пример1](src/ITVDN/Part4_Interface_Segregation_Principle/part42_isp_solution),
[Пример2](src/ITVDN/Part4_Interface_Segregation_Principle/part44_order_isp_solution)

## __D__ - __DIP__

__Dependency inversion__ - Принцип инверсии зависимостей

> * Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
> * Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Наиболее гибкими являются системы, в которых зависимости исходного кода относятся только к абстракциям, а не к реализациям.

Зависимости исходного кода не должны ссылаться на конкретные модули.

__Модуль нижнего уровня__: Интерфейс пользователя

__Модуль верхнего уровня__: Бизнес логика

Стабильные программные архитектуры - те, которые избегают зависимости от реализаций, которые могут в любой момент могут измениться, и предпочитают использование стабильных абстрактных классов или интерфейсов.

Такое решение предполагает использование некоторых правил:
* Все переменные-члена класса должны быть или абстрактными классами или интерфейсами
* Классы не должны наследоваться от не абстрактных классов или интерфейсов
* Методы не должны замещать методы реализаций
* Никогда не упоминайте название чего-либо конкретного

__Приложение, которое нарушает принцип DIP__:
[Пример](src/ITVDN/Part5_Dependency_Inversion_Pranciple/part51_dip_violation)

__Приложение, которое поддерживает принцип DIP__:
[Пример](src/ITVDN/Part5_Dependency_Inversion_Pranciple/part52_dip_solution)